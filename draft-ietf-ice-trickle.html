<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol</title>

  <style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
}
ul.toc, ul.toc ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Determining Support for Trickle ICE"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Sending the Initial Offer"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Receiving the Initial Offer"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Sending the Initial Answer"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Forming Check Lists and Beginning Connectivity                       Checks"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Receiving the Initial Answer"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Performing Connectivity Checks"/>
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Scheduling Checks"/>
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Check List and Timer State Updates"/>
<link href="#rfc.section.8" rel="Chapter" title="8 Discovering and Sending Additional Local Candidates"/>
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Pairing Newly Learned Candidates and Updating                       Check Lists"/>
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Announcing End of Candidates"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Receiving Additional Remote Candidates"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Receiving an End-Of-Candidates Notification"/>
<link href="#rfc.section.11" rel="Chapter" title="11 Trickle ICE and Peer Reflexive Candidates"/>
<link href="#rfc.section.12" rel="Chapter" title="12 Concluding ICE Processing"/>
<link href="#rfc.section.13" rel="Chapter" title="13 Subsequent Offer/Answer Exchanges"/>
<link href="#rfc.section.14" rel="Chapter" title="14 Unilateral Use of Trickle ICE (Half Trickle)"/>
<link href="#rfc.section.15" rel="Chapter" title="15 Example Flow"/>
<link href="#rfc.section.16" rel="Chapter" title="16 IANA Considerations"/>
<link href="#rfc.section.17" rel="Chapter" title="17 Security Considerations"/>
<link href="#rfc.section.18" rel="Chapter" title="18 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="19 References"/>
<link href="#rfc.references.1" rel="Chapter" title="19.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="19.2 Informative References"/>
<link href="#rfc.appendix.A" rel="Chapter" title="A Interaction with ICE"/>
<link href="#rfc.appendix.B" rel="Chapter" title="B Interaction with ICE Lite"/>
<link href="#rfc.appendix.C" rel="Chapter" title="C Changes from Earlier Versions"/>
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Changes from draft-ietf-ice-trickle-00"/>
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Changes from draft-mmusic-trickle-ice-02"/>
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Changes from draft-ivov-01 and draft-mmusic-00"/>
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Changes from draft-ivov-00"/>
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Changes from draft-rescorla-01"/>
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Changes from draft-rescorla-00"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Ivov, E., Rescorla, E., Uberti, J., and P. Saint-Andre" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-ice-trickle-01" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-12-17" />
  <meta name="dct.abstract" content="This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that enables ICE agents to send and receive candidates incrementally rather than exchanging complete lists. With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete. This mechanism is called &quot;trickle ICE&quot;.  " />
  <meta name="description" content="This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that enables ICE agents to send and receive candidates incrementally rather than exchanging complete lists. With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete. This mechanism is called &quot;trickle ICE&quot;.  " />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Network Working Group</td>
  <td class="right">E. Ivov</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Jitsi</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">E. Rescorla</td>
</tr>
<tr>
  <td class="left">Expires: June 19, 2016</td>
  <td class="right">RTFM, Inc.</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">J. Uberti</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">Google</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">P. Saint-Andre</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">&amp;yet</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">December 17, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Trickle ICE: Incremental Provisioning of Candidates for the Interactive Connectivity Establishment (ICE) Protocol<br />
  <span class="filename">draft-ietf-ice-trickle-01</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes an extension to the Interactive Connectivity Establishment (ICE) protocol that enables ICE agents to send and receive candidates incrementally rather than exchanging complete lists. With such incremental provisioning, ICE agents can begin connectivity checks while they are still gathering candidates and considerably shorten the time necessary for ICE processing to complete. This mechanism is called "trickle ICE".  </p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 19, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<li>2.   <a href="#rfc.section.2">Terminology</a></li>
<li>3.   <a href="#rfc.section.3">Determining Support for Trickle ICE</a></li>
<li>4.   <a href="#rfc.section.4">Sending the Initial Offer</a></li>
<li>5.   <a href="#rfc.section.5">Receiving the Initial Offer</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Sending the Initial Answer</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Forming Check Lists and Beginning Connectivity                       Checks</a></li>
</ul><li>6.   <a href="#rfc.section.6">Receiving the Initial Answer</a></li>
<li>7.   <a href="#rfc.section.7">Performing Connectivity Checks</a></li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Scheduling Checks</a></li>
<li>7.2.   <a href="#rfc.section.7.2">Check List and Timer State Updates</a></li>
</ul><li>8.   <a href="#rfc.section.8">Discovering and Sending Additional Local Candidates</a></li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Pairing Newly Learned Candidates and Updating                       Check Lists</a></li>
<li>8.2.   <a href="#rfc.section.8.2">Announcing End of Candidates</a></li>
</ul><li>9.   <a href="#rfc.section.9">Receiving Additional Remote Candidates</a></li>
<li>10.   <a href="#rfc.section.10">Receiving an End-Of-Candidates Notification</a></li>
<li>11.   <a href="#rfc.section.11">Trickle ICE and Peer Reflexive Candidates</a></li>
<li>12.   <a href="#rfc.section.12">Concluding ICE Processing</a></li>
<li>13.   <a href="#rfc.section.13">Subsequent Offer/Answer Exchanges</a></li>
<li>14.   <a href="#rfc.section.14">Unilateral Use of Trickle ICE (Half Trickle)</a></li>
<li>15.   <a href="#rfc.section.15">Example Flow</a></li>
<li>16.   <a href="#rfc.section.16">IANA Considerations</a></li>
<li>17.   <a href="#rfc.section.17">Security Considerations</a></li>
<li>18.   <a href="#rfc.section.18">Acknowledgements</a></li>
<li>19.   <a href="#rfc.references">References</a></li>
<ul><li>19.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>19.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Interaction with ICE</a></li>
<li>Appendix B.   <a href="#rfc.appendix.B">Interaction with ICE Lite</a></li>
<li>Appendix C.   <a href="#rfc.appendix.C">Changes from Earlier Versions</a></li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Changes from draft-ietf-ice-trickle-00</a></li>
<li>C.2.   <a href="#rfc.appendix.C.2">Changes from draft-mmusic-trickle-ice-02</a></li>
<li>C.3.   <a href="#rfc.appendix.C.3">Changes from draft-ivov-01 and draft-mmusic-00</a></li>
<li>C.4.   <a href="#rfc.appendix.C.4">Changes from draft-ivov-00</a></li>
<li>C.5.   <a href="#rfc.appendix.C.5">Changes from draft-rescorla-01</a></li>
<li>C.6.   <a href="#rfc.appendix.C.6">Changes from draft-rescorla-00</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> Introduction</h1>
<p id="rfc.section.1.p.1">The Interactive Connectivity Establishment (ICE) protocol <a href="#rfc5245bis">[rfc5245bis]</a> describes mechanisms for gathering candidates, prioritizing them, choosing default ones, exchanging them with the remote party, pairing them, and ordering them into check lists. Once all of these actions have been completed (and only then), the participating agents can begin a phase of connectivity checks and eventually select the pair of candidates that will be used in a media session.  </p>
<p id="rfc.section.1.p.2">Although the sequence described above has the advantage of being relatively straightforward to implement and debug once deployed, it can also be rather lengthy.  Candidate gathering often involves things like querying <a href="#RFC5389">STUN</a> <cite title="NONE">[RFC5389]</cite> servers, discovering UPnP devices, and allocating relayed candidates at <a href="#RFC5766">TURN</a> <cite title="NONE">[RFC5766]</cite> servers. All of these actions can be delayed for a noticeable amount of time; although they can be run in parallel, they still need to respect the pacing requirements from <a href="#rfc5245bis">[rfc5245bis]</a>, which is likely to delay them even further. Some or all of these actions also need be completed by the remote agent. Both agents would next perform connectivity checks and only then would they be ready to begin streaming media.  </p>
<p id="rfc.section.1.p.3">These factors can lead to relatively lengthy session establishment times and degraded user experience.  </p>
<p id="rfc.section.1.p.4">This document defines an alternative mode of operation for ICE implementations, known as "Trickle ICE", in which candidates can be exchanged incrementally. This enables ICE agents to exchange candidates as soon as a session has been initiated. Connectivity checks for a media stream can also start as soon as the first candidates for that stream become available.  </p>
<p id="rfc.section.1.p.5">Trickle ICE can reduce session establishment times in cases where connectivity is confirmed for the first exchanged candidates (e.g., where the host candidates for one of the agents are directly reachable from the second agent, such as host candidates at a media relay). Even when this is not the case, running candidate gathering for both agents and connectivity checks in parallel can considerably shorten ICE processing times.  </p>
<p id="rfc.section.1.p.6">It is worth noting that there is quite a bit of operational experience with the Trickle ICE technique, going back as far as 2005 (when the XMPP Jingle extension defined a "dribble mode" as specified in <a href="#XEP-0176">[XEP-0176]</a>); this document incorporates feedback from those who have implemented and deployed the technique.  </p>
<p id="rfc.section.1.p.7">In addition to the basics of Trickle ICE, this document also describes how to discover support for Trickle ICE, how regular ICE processing needs to be modified when building and updating check lists, and how Trickle ICE implementations interoperate with agents that only implement so-called "Vanilla ICE" processing as defined in <a href="#rfc5245bis">[rfc5245bis]</a>.  </p>
<p id="rfc.section.1.p.8">This specification does not define the usage of Trickle ICE with any specific signalling protocol (however, see <a href="#I-D.ietf-mmusic-trickle-ice-sip">[I-D.ietf-mmusic-trickle-ice-sip]</a> for usage with SIP <a href="#RFC3261">[RFC3261]</a>).  Similarly, it does not define Trickle ICE in terms of the Session Description Protocol (SDP) <a href="#RFC4566">[RFC4566]</a> or the offer/answer model <a href="#RFC3264">[RFC3264]</a> because the technique can be and already is used in application protocols that are not tied to SDP or to offer/answer semantics.  </p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> Terminology</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.  </p>
<p id="rfc.section.2.p.2">This specification makes use of all terminology defined for Interactive Connectivity Establishment in <a href="#rfc5245bis">[rfc5245bis]</a>.  </p>
<p/>

<dl>
  <dt>Vanilla ICE:</dt>
  <dd style="margin-left: 8">The Interactive Connectivity Establishment protocol as defined in <a href="#rfc5245bis">[rfc5245bis]</a>.  </dd>
  <dt>Candidate Harvester:</dt>
  <dd style="margin-left: 8">A module used by an ICE agent to obtain local candidates.  Candidate gatherers use different mechanisms for discovering local candidates. Some of them would typically make use of protocols such as STUN or TURN. Others may also employ techniques that are not referenced within <a href="#rfc5245bis">[rfc5245bis]</a> (e.g., UPnP based port allocation or XMPP Jingle Relay Nodes <a href="#XEP-0278">[XEP-0278]</a>).  </dd>
  <dt>Trickled Candidates:</dt>
  <dd style="margin-left: 8">Candidates that a Trickle ICE agent sends after an offer or answer but within the same context.  Trickled candidates can be sent in parallel with candidate gathering and connectivity checks.  </dd>
  <dt>Trickling/Trickle (v.):</dt>
  <dd style="margin-left: 8">The act of sending trickled candidates.  </dd>
  <dt>Half Trickle:</dt>
  <dd style="margin-left: 8">A Trickle ICE mode of operation where the offerer gathers its first generation of candidates strictly before creating and sending the offer. Once sent, that offer can be processed by Vanilla ICE agents and does not require support for this specification. It also allows Trickle ICE capable answerers to still gather candidates and perform connectivity checks in a non-blocking way, thus roughly offering "half" the advantages of Trickle ICE. The mechanism is mostly meant for use in cases where support for trickle ICE cannot be confirmed prior to sending a initial offer.  </dd>
  <dt>Full Trickle:</dt>
  <dd style="margin-left: 8">The regular mode of operation for Trickle ICE agents, in which an initial offer can include any number of candidates (even zero candidates) and does not need to include the entire first generation of candidates as in half trickle.  </dd>
</dl>

<p> </p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#disco" id="disco">Determining Support for Trickle ICE</a></h1>
<p id="rfc.section.3.p.1">Application protocols that use Trickle ICE should do one of the following: </p>
<p/>

<ul>
  <li>Provide a way for agents to verify support of Trickle ICE prior to initiating a session (XMPP's <a href="#XEP-0030">Service Discovery</a> <cite title="NONE">[XEP-0030]</cite> is one such mechanism).  </li>
  <li>Make support for Trickle ICE mandatory so that user agents can assume support.  </li>
</ul>

<p> </p>
<p id="rfc.section.3.p.3">Alternately, for cases where a protocol provides neither of the foregoing methods, agents may rely on provisioning/configuration or use the half trickle procedure described in <a href="#half-trickle">Section 14</a>.  </p>
<p id="rfc.section.3.p.4">Prior to sending an initial offer, agents using signaling protocols that support capabilities discovery can attempt to verify whether or not the remote party supports Trickle ICE. If an agent determines that the remote party does not support Trickle ICE, it MUST fall back to using Vanilla ICE or abandon the entire session.  </p>
<p id="rfc.section.3.p.5">In application protocols that use SDP, a user agent supporting Trickle ICE MUST include a token of "trickle" in the ice-options attribute every time it generates an offer or an answer.  This enables an agent that receives offers or answers to verify support by checking for presence of the token.  </p>
<p id="rfc.section.3.p.6">Dedicated discovery semantics and half trickle are needed only prior to session initiation (e.g., when sending the initial offer). After a session is established and Trickle ICE support is confirmed for both parties, either agent can use full trickle for subsequent offers.  </p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#initial-offer" id="initial-offer">Sending the Initial Offer</a></h1>
<p id="rfc.section.4.p.1">An agent starts gathering candidates as soon as it has an indication that communication is imminent (e.g., a user interface cue or an explicit request to initiate a session). Contrary to Vanilla ICE, implementations of Trickle ICE do not need to gather candidates in a blocking manner. Therefore, unless half trickle is being used, agents SHOULD generate and transmit their initial offer as early as possible, in order to allow the remote party to start gathering and trickling candidates.  </p>
<p id="rfc.section.4.p.2">Trickle ICE agents MAY include any set of candidates in an offer. This includes the possibility of sending an offer that contains all the candidates that the agent plans to use (as in half trickle mode), sending an offer that contains only a publically-reachable IP address (e.g., a host candidate at a media relay that is known to not be behind a firewall), or sending an offer with no candidates at all (in which case the offerer can receive the answerer's initial candidate list sooner and the answerer can begin candidate gathering more quickly).  </p>
<p id="rfc.section.4.p.3">For optimal performance, it is RECOMMENDED that the candidates in an initial offer (if any) be host candidates only. This would allow both agents to start gathering server reflexive, relayed, and other non-host candidates simultaneously, and it would also enable them to begin connectivity checks.  </p>
<p id="rfc.section.4.p.4">If the privacy implications of revealing host addresses on an endpoint device are a concern, agents can generate an offer that contains no candidates and then only trickle candidates that do not reveal host addresses (e.g., relayed candidates).  </p>
<p id="rfc.section.4.p.5">Methods for calculating priorities and foundations, as well as determining redundancy of candidates, work just as with vanilla ICE.  </p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> Receiving the Initial Offer</h1>
<p id="rfc.section.5.p.1">When an agent receives an initial offer, it will first check if the offer or offerer indicates support for Trickle ICE as explained in <a href="#disco">Section 3</a>. If this is not the case, the agent MUST process the offer according to Vanilla ICE procedures <a href="#rfc5245bis">[rfc5245bis]</a> or offer/answer processing rules <a href="#RFC3264">[RFC3264]</a> if no ICE support is detected at all.  </p>
<p id="rfc.section.5.p.2">If support for Trickle ICE is confirmed, an agent will automatically assume support for Vanilla ICE as well even if the support verification procedure in <a href="#rfc5245bis">[rfc5245bis]</a> indicates otherwise. Specifically, the rules from <a href="#rfc5245bis">[rfc5245bis]</a> would imply that ICE itself is not supported if the initial offer includes no candidates in the offer; however, such a conclusion is not warranted if the answerer can confirm that the offerer supports Trickle ICE and thus fallback to <a href="#RFC3264">[RFC3264]</a> is not necessary.  </p>
<p id="rfc.section.5.p.3">If the offer does indicate support for Trickle ICE, the agent will determine its role, start gathering and prioritizing candidates and while doing so it will also respond by sending its own answer, so that both agents can start forming check lists and begin connectivity checks.  </p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> Sending the Initial Answer</h1>
<p id="rfc.section.5.1.p.1">An agent can respond to an initial offer at any point while gathering candidates. The answer can again contain any set of candidates, including all candidates or no candidates. (The benefit of including no candidates is to send the answer as quickly as possible, so that both parties can consider the overall session to be under active negotiation as soon as possible.) Unless the answering agent is protecting host addresses for privacy reasons, it would typically construct this initial answer including only host addresses, thus enabling the remote party to also start forming check lists and performing connectivity checks.  </p>
<p id="rfc.section.5.1.p.2">In application protocols that use SDP, the answer MUST indicate support for Trickle ICE as described in <a href="#disco">Section 3</a>.  </p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#check.lists" id="check.lists">Forming Check Lists and Beginning Connectivity                       Checks</a></h1>
<p id="rfc.section.5.2.p.1">After exchanging the offer and answer, and as soon as they have obtained local and remote candidates, agents begin forming candidate pairs, computing candidate pair priorities and ordering candidate pairs, pruning duplicate pairs, and creating check lists according to the Vanilla ICE procedures described in <a href="#rfc5245bis">[rfc5245bis]</a>.  </p>
<p id="rfc.section.5.2.p.2">According to those procedures, in order for candidate pairing to be possible and for duplicate candidates to be pruned, the candidates would need to be provided in both the offer and the answer. Under Trickle ICE, check lists can be empty until candidate pairs are sent or received. Therefore Trickle ICE agents handle check lists and candidate pairing in a slightly different way: the agents still create the check lists, but they only populate the check lists after they actually have the candidate pairs.  </p>
<p/>

<ul class="empty">
  <li>Note: According to <a href="#rfc5245bis">[rfc5245bis]</a>, "A check list with at least one pair that is Waiting is called an active check list, and a check list with all pairs Frozen is called a frozen check list." Formally speaking an active check list does not have a state of Active and a frozen check list does not have a state of Frozen, because the only check list states are Running, Completed, and Failed.  </li>
</ul>

<p> </p>
<p id="rfc.section.5.2.p.4">A Trickle ICE agent MUST initially consider all check lists to be frozen.  It then inspects the first check list and attempts to unfreeze all candidates belonging to the first component on the first media stream (i.e., the first media stream that was reported to the ICE implementation from the using application). However, if this check list is still empty, an agent delays further processing until the check list is non-empty.  </p>
<p id="rfc.section.5.2.p.5">With regard to pruning of duplicate candidate pairs, a Trickle ICE agent SHOULD follow a policy of "first one wins" and not re-apply the pruning procedure if a higher-priority candidate pair is received from the remote agent.  </p>
<p id="rfc.section.5.2.p.6">Respecting the order in which check lists have been reported to an ICE implementation is crucial to the frozen candidates algorithm, so that connectivity checks are performed simultaneously by both agents.  </p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> Receiving the Initial Answer</h1>
<p id="rfc.section.6.p.1">When receiving an answer, agents follow Vanilla ICE procedures to determine their role, after which they form check lists (as described in <a href="#check.lists">Section 5.2</a>) and begin connectivity checks.  </p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> Performing Connectivity Checks</h1>
<p id="rfc.section.7.p.1">For the most part, Trickle ICE agents perform connectivity checks following Vanilla ICE procedures. However, the asynchronous nature of gathering and communicating candidates in Trickle ICE impose a number of changes described as described in the following sections.  </p>
<h1 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a> <a href="#scheduling-checks" id="scheduling-checks">Scheduling Checks</a></h1>
<p id="rfc.section.7.1.p.1">The ICE specification <a href="#rfc5245bis">[rfc5245bis]</a>, Section 5.8, requires that agents terminate the timer for a triggered check in relation to an active check list once the agent has exhausted all frozen pairs in check list.  This will not work with Trickle ICE, because more pairs will be added to the check list incrementally.  </p>
<p id="rfc.section.7.1.p.2">Therefore, a Trickle ICE agent SHOULD NOT terminate the timer until the state of the check list is Completed or Failed as specified herein (see <a href="#end-of-candidates">Section 8.2</a>).  </p>
<h1 id="rfc.section.7.2"><a href="#rfc.section.7.2">7.2.</a> <a href="#state-updates" id="state-updates">Check List and Timer State Updates</a></h1>
<p id="rfc.section.7.2.p.1">The ICE specification <a href="#rfc5245bis">[rfc5245bis]</a>, Section 7.1.3.3, requires that agents update check lists and timer states upon completing a connectivity check transaction. During such an update, Vanilla ICE agents would set the state of a check list to Failed if both of the following two conditions are satisfied: </p>
<p/>

<ul>
  <li>all of the pairs in the check list are either in the Failed or Succeeded state; and </li>
  <li>there is not a pair in the valid list for each component of the media stream.  </li>
</ul>

<p> </p>
<p id="rfc.section.7.2.p.3">With Trickle ICE, the above situation would often occur when candidate gathering and trickling are still in progress, even though it is quite possible that future checks will succeed. For this reason, Trickle ICE agents add the following conditions to the above list: </p>
<p/>

<ul>
  <li>all candidate gatherers have completed and the agent is not expecting to discover any new local candidates; </li>
  <li>the remote agent has sent an end-of-candidates indication for that check list as described in <a href="#end-of-candidates">Section 8.2</a>.  </li>
</ul>

<p> </p>
<p id="rfc.section.7.2.p.5">Vanilla ICE requires that agents then update all other check lists, placing one pair from each of them into the Waiting state, effectively unfreezing all remaining check lists. However, under Trickle ICE other check lists might still be empty at that point. Therefore a Trickle ICE agent SHOULD monitor whether a check list is active or frozen independently of the state of the candidate pairs that the check list contains. A Trickle ICE agent SHOULD consider a check list to be active either when unfreezing the first candidate pair in the check list or when there is no candidate pair in the check list (i.e., when the check list is empty).  </p>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#send-trickling" id="send-trickling">Discovering and Sending Additional Local Candidates</a></h1>
<p id="rfc.section.8.p.1">After an offer or an answer has been sent, agents will most likely continue discovering new local candidates as STUN, TURN, and other non-host candidate gathering mechanisms begin to yield results. Whenever an agent discovers such a new candidate it will compute its priority, type, foundation and component ID according to normal Vanilla ICE procedures.  </p>
<p id="rfc.section.8.p.2">The new candidate is then checked for redundancy against the existing list of local candidates. If its transport address and base match those of an existing candidate, it will be considered redundant and will be ignored. This would often happen for server reflexive candidates that match the host addresses they were obtained from (e.g., when the latter are public IPv4 addresses). Contrary to Vanilla ICE, Trickle ICE agents will consider the new candidate redundant regardless of its priority.  </p>
<p id="rfc.section.8.p.3">Next the agent sends (i.e., trickles) the newly discovered candidate(s) to the remote agent. The actual delivery of the new candidates are specified by using protocols such as SIP or XMPP.  Trickle ICE imposes no restrictions on the way this is done or whether it is done at all. For example, some applications may choose not to send trickle updates for server reflexive candidates and rely on the discovery of peer reflexive ones instead.  </p>
<p id="rfc.section.8.p.4">When trickle updates are sent, each candidate MUST be delivered to the receiving Trickle ICE implementation not more than once and in the same order that they were sent. In other words, if there are any candidate retransmissions, they must be hidden from the ICE implementation.  </p>
<p id="rfc.section.8.p.5">Also, candidate trickling needs to be correlated to a specific ICE negotiation session, so that if there is an ICE restart, any delayed updates for a previous session can be recognized as such and ignored by the receiving party.  </p>
<p id="rfc.section.8.p.6">One important aspect of Vanilla ICE is that connectivity checks for a specific foundation and component are attempted simultaneously by both agents, so that any firewalls or NATs fronting the agents would whitelist both endpoints and allow all except for the first ("suicide") packets to go through. This is also crucial to unfreezing candidates in the right time.  </p>
<p id="rfc.section.8.p.7">In order to preserve this feature in Trickle ICE, when trickling candidates agents MUST respect the order of the components as they appear (implicitly or explicitly) in the offer/answer descriptions. Therefore a candidate for a specific component MUST NOT be sent prior to candidates for other components within the same foundation.  </p>
<pre>

  v=0
  o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1
  s=
  c=IN IP4 10.0.1.1
  t=0 0
  a=ice-pwd:asd88fgpdd777uzjYhagZg
  a=ice-ufrag:8hhY
  m=audio 5000 RTP/AVP 0
  a=rtpmap:0 PCMU/8000
  a=candidate:1 1 UDP 2130706431 10.0.1.1 5000 typ host
  a=candidate:1 2 UDP 2130706431 10.0.1.1 5001 typ host
  a=candidate:2 1 UDP 1694498815 192.0.2.3 5000 typ srflx
      raddr 10.0.1.1 rport 8998
  a=candidate:2 2 UDP 1694498815 192.0.2.3 5001 typ srflx
      raddr 10.0.1.1 rport 8998

          </pre>
<p id="rfc.section.8.p.8">For example, the following SDP description contains two components (RTP and RTCP) and two foundations (host and server reflexive): </p>
<p id="rfc.section.8.p.9">Note that the order restriction only applies among candidates that belong to the same foundation.  </p>
<p id="rfc.section.8.p.10">It is also equally important to preserve this order across media streams, which is covered by the requirement to always start unfreezing candidates starting from the first media stream as described under <a href="#check.lists">Section 5.2</a>.  </p>
<p id="rfc.section.8.p.11">Once the candidate has been sent to the remote party, the agent checks if any remote candidates are currently known for this same stream. If not, the new candidate will simply be added to the list of local candidates.  </p>
<p id="rfc.section.8.p.12">Otherwise, if the agent has already learned of one or more remote candidates for this stream and component, it will begin pairing the new local candidates with them and adding the pairs to the existing check lists according to their priority.  </p>
<h1 id="rfc.section.8.1"><a href="#rfc.section.8.1">8.1.</a> <a href="#cand-pairing" id="cand-pairing">Pairing Newly Learned Candidates and Updating                       Check Lists</a></h1>
<p id="rfc.section.8.1.p.1">Forming candidate pairs works the way it is described by the ICE specification <a href="#rfc5245bis">[rfc5245bis]</a>.  However, actually adding the new pair to a check list happens according to the rules described below.  </p>
<p id="rfc.section.8.1.p.2">If the check list where the pair is to be added already contains the maximum number of candidate pairs (100 by default as per <a href="#rfc5245bis">[rfc5245bis]</a>), the new pair is discarded.  </p>
<p id="rfc.section.8.1.p.3">If the new pair's local candidate is server reflexive, the server reflexive candidate MUST be replaced by its base before adding the pair to the list. Once this is done, the agent examines the check list looking for another pair that would be redundant with the new one. If such a pair exists, the newly formed pair is ignored.  </p>
<p id="rfc.section.8.1.p.4">For all other pairs, including those with a server reflexive local candidate that were not found to be redundant: </p>

<ul>
  <li>if this check list is frozen then the new pair will be assigned a state of Frozen.  </li>
  <li>else if the check list is active and it is either empty or contains only candidates in the Succeeded and Failed states, then the new pair's state is set to Waiting.  </li>
  <li>else if the check list is non-empty and active, then the state of the new pair will be set to <dl><dt>Frozen: </dt><dd style="margin-left: 8">if there is at least one pair in the check list whose foundation matches the one in the new pair and whose state is neither Succeeded nor Failed (eventually the new pair will get unfrozen after the ongoing check for the existing pair concludes); </dd><dt>Waiting: </dt><dd style="margin-left: 8">if the list contains no pairs with the same foundation as the new one, or, in case such pairs exist but they are all in either the Succeeded or Failed states.  </dd></dl><p> </p></li>
</ul>

<p> </p>
<h1 id="rfc.section.8.2"><a href="#rfc.section.8.2">8.2.</a> <a href="#end-of-candidates" id="end-of-candidates">Announcing End of Candidates</a></h1>
<p id="rfc.section.8.2.p.1">Once all candidate gathering is completed or expires for a specific media stream, the agents will generate an "end-of-candidates" indication for that stream and send it to the remote agent via the signalling channel. The exact form of the indication depends on the application protocol. The indication can be sent in the following ways: </p>

<ul>
  <li>As part of an offer (which would typically be the case with half trickle initial offers)</li>
  <li>Along with the last candidate an agent can send for a stream</li>
  <li>As a standalone notification (e.g., after STUN Binding requests or TURN Allocate requests to a server timeout and the agent has no other active gatherers)</li>
</ul>

<p> </p>
<p id="rfc.section.8.2.p.2">A controlled Trickle ICE agent SHOULD send end-of-candidates indications after gathering for a media stream has completed, unless ICE processing terminates before the agent has had a chance to do so. Sending the indication is necessary in order to avoid ambiguities and speed up the conclusion of ICE processing. On the other hand, a controlling agent MAY conclude ICE processing prior to sending end-of-candidates indications for all streams. This would typically be the case with aggressive nomination. However, it is RECOMMENDED that controlling agents do send such indications whenever possible for the sake of consistency and to keep middle boxes and controlled agents up-to-date on the state of ICE processing.  </p>
<p id="rfc.section.8.2.p.3">When sending an end-of-candidate indication during trickling (rather than as a part of an offer or an answer), it is the responsibility of the using protocol to define methods for relating the indication to one or more specific media streams.  </p>
<p id="rfc.section.8.2.p.4">Receiving an end-of-candidates indication enables an agent to update check list states and, in case valid pairs do not exist for every component in every media stream, determine that ICE processing has failed. It also enables agents to speed up the conclusion of ICE processing when a candidate pair has been validated but it involves the use of lower-preference transports such as TURN. In such situations, an implementations may choose to wait and see if higher-priority candidates are received; in this case the end-of-candidates indication provides a notificaiton that such candidates are not forthcoming.  </p>
<p id="rfc.section.8.2.p.5">An agent MAY also choose to generate an end-of-candidates indication before candidate gathering has actually completed, if the agent determines that gathering has continued for more than an acceptable period of time. However, an agent MUST NOT send any more candidates after it has send an end-of-candidates indication.  </p>
<p id="rfc.section.8.2.p.6">When performing half trickle, an agent SHOULD send an end-of-candidates indication together with its initial offer unless it is planning to potentially send additional candidates (e.g., in case the remote party turns out to support Trickle ICE).  </p>
<p id="rfc.section.8.2.p.7">When an end-of-candidates indication is sent as part of an offer or an answer, it can be considered to apply to the session as a whole, which is equivalent to having it apply to all media streams.  </p>
<p id="rfc.section.8.2.p.8">After an agent sends the end-of-candidates indication, it will update the state of the corresponding check list as explained in <a href="#state-updates">Section 7.2</a>. Past that point, an agent MUST NOT send any new candidates within this ICE session.  After an agent has received an end-of-candidates indication, it MUST also ignore any newly received candidates for that media stream or media session. Therefore, adding new candidates to the negotiation is possible only through an ICE restart.  </p>
<p id="rfc.section.8.2.p.9">This specification does not override Vanilla ICE semantics for concluding ICE processing.  Therefore even if end-of-candidates indications are sent agents will still have to go through pair nomination. Also, if pairs have been nominated for components and media streams, ICE processing will still conclude even if end-of-candidate indications have not been received for all streams.  </p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#recv-trickling" id="recv-trickling">Receiving Additional Remote Candidates</a></h1>
<p id="rfc.section.9.p.1">At any point of ICE processing, a Trickle ICE agent may receive new candidates from the remote agent. When this happens and no local candidates are currently known for this same stream, the new remote candidates are simply added to the list of remote candidates.  </p>
<p id="rfc.section.9.p.2">Otherwise, the new candidates are used for forming candidate pairs with the pool of local candidates and they are added to the local check lists as described in <a href="#cand-pairing">Section 8.1</a>.  </p>
<p id="rfc.section.9.p.3">Once the remote agent has completed candidate gathering, it will send an end-of-candidates indication. Upon receiving such an indication, the local agent MUST update check list states as per <a href="#state-updates">Section 7.2</a>. This may lead to some check lists being marked as Failed.  </p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#end-of-candidates.recv" id="end-of-candidates.recv">Receiving an End-Of-Candidates Notification</a></h1>
<p id="rfc.section.10.p.1">When an agent receives an end-of-candidates indication for a specific check list, it will update the state of the check list as per <a href="#state-updates">Section 7.2</a>. If the check list is still active state after the update, the agent will persist the the fact that an end-of-candidates indication has been received and take it into account in future updates to the check list.  </p>
<h1 id="rfc.section.11"><a href="#rfc.section.11">11.</a> Trickle ICE and Peer Reflexive Candidates</h1>
<p id="rfc.section.11.p.1">Even though Trickle ICE does not explicitly modify the procedures for handling peer reflexive candidates, their processing could be impacted in implementations. With Trickle ICE, it is possible that server reflexive candidates can be discovered as peer reflexive in cases where incoming connectivity checks are received from these candidates before the trickle updates that carry them.  </p>
<p id="rfc.section.11.p.2">While this would certainly increase the number of cases where ICE processing nominates and selects candidates discovered as peer-reflexive, it does not require any change in processing.  </p>
<p id="rfc.section.11.p.3">It is also likely that some applications would prefer not to trickle server reflexive candidates to entities that are known to be publicly accessible and where sending a direct STUN binding request is likely to reach the destination faster than the trickle update that travels through the signalling path.  </p>
<h1 id="rfc.section.12"><a href="#rfc.section.12">12.</a> <a href="#concluding.ice" id="concluding.ice">Concluding ICE Processing</a></h1>
<p id="rfc.section.12.p.1">This specification does not directly modify the procedures ending ICE processing described in Section 8 of <a href="#rfc5245bis">[rfc5245bis]</a>, and Trickle ICE implementations will follow the same rules.  </p>
<p/>
<h1 id="rfc.section.13"><a href="#rfc.section.13">13.</a> <a href="#subsequent.oa" id="subsequent.oa">Subsequent Offer/Answer Exchanges</a></h1>
<p id="rfc.section.13.p.1">Either agent MAY generate a subsequent offer at any time allowed by <a href="#RFC3264">[RFC3264]</a>. When this happens agents will use <a href="#rfc5245bis">[rfc5245bis]</a> semantics to determine whether or not the new offer requires an ICE restart. If this is the case then agents would perform Trickle ICE as they would in an initial offer/answer exchange.  </p>
<p id="rfc.section.13.p.2">The only differences between an ICE restart and a brand new media session are that: </p>
<p/>

<ul>
  <li>during the restart, media can continue to be sent to the previously validated pair.  </li>
  <li>both agents are already aware whether or not their peer supports Trickle ICE, and there is no longer need for performing half trickle or confirming support with other mechanisms.  </li>
</ul>

<p> </p>
<h1 id="rfc.section.14"><a href="#rfc.section.14">14.</a> <a href="#half-trickle" id="half-trickle">Unilateral Use of Trickle ICE (Half Trickle)</a></h1>
<p id="rfc.section.14.p.1">In half trickle mode, the offerer sends a regular, Vanilla ICE offer, with a complete set of candidates. This ensures that the offer can be processed by a Vanilla ICE answerer and is mostly meant for use in cases where support for Trickle ICE cannot be confirmed prior to sending an initial offer.  The initial offer indicates support for Trickle ICE, so that the answerer can respond with an incomplete set of candidates and continue trickling the rest.  Half trickle offers typically contain an end-of-candidates indication, although this is not mandatory because if trickle support is confirmed then the offerer can choose to trickle additional candidates before it sends an end-of-candidates indication.  </p>
<p id="rfc.section.14.p.2">The half trickle mechanism can be used in cases where there is no way for an agent to verify in advance whether a remote party supports Trickle ICE. Because the initial offer contains a full set of candidates, it can thus be handled by a regular Vanilla ICE agent, while still allowing a Trickle ICE agent to use the optimization defined in this specification. This prevents negotiation from failing in the former case while still giving roughly half the Trickle ICE benefits in the latter (hence the name of the mechanism).  </p>
<p id="rfc.section.14.p.3">Use of half trickle is only necessary during an initial offer/answer exchange. After both parties have received a session description from their peer, they can each reliably determine Trickle ICE support and use it for all subsequent offer/answer exchanges.  </p>
<p id="rfc.section.14.p.4">In some instances, using half trickle might bring more than just half the improvement in terms of user experience. This can happen when an agent starts gathering candidates upon user interface cues that the user will soon be initiating an offer, such as activity on a keypad or the phone going off hook. This would mean that some or all of the candidate gathering could be completed before the agent actually needs to send the offer. Because the answerer will be able to trickle candidates, both agents will be able to start connectivity checks and complete ICE processing earlier than with Vanilla ICE and potentially even as early as with full trickle.  </p>
<p id="rfc.section.14.p.5">However, such anticipation is not always possible. For example, a multipurpose user agent or a WebRTC web page where communication is a non-central feature (e.g., calling a support line in case of a problem with the main features) would not necessarily have a way of distinguishing between call intentions and other user activity. In such cases, using full trickle is most likely to result in an ideal user experience.  Even so, using half trickle would be an improvement over vanilla ICE because it would result in a better experience for answerers.  </p>
<h1 id="rfc.section.15"><a href="#rfc.section.15">15.</a> Example Flow</h1>
<p id="rfc.section.15.p.1">A typical successful Trickle ICE exchange with an Offer/Answer protocol would look this way: </p>
<div id="rfc.figure.1"/>
<div id="fig-example"/>
<pre>

        Alice                                            Bob
          |                     Offer                     |
          |----------------------------------------------&gt;|
          |            Additional Candidates              |
          |----------------------------------------------&gt;|
          |                                               |
          |                     Answer                    |
          |&lt;----------------------------------------------|
          |            Additional Candidates              |
          |&lt;----------------------------------------------|
          |                                               |
          | Additional Candidates and Connectivity Checks |
          |&lt;---------------------------------------------&gt;|
          |                                               |
          |&lt;=============== MEDIA FLOWS =================&gt;|


        </pre>
<p class="figure">Figure 1: Example </p>
<h1 id="rfc.section.16"><a href="#rfc.section.16">16.</a> IANA Considerations</h1>
<p id="rfc.section.16.p.1">This specification requests no actions from IANA.</p>
<h1 id="rfc.section.17"><a href="#rfc.section.17">17.</a> Security Considerations</h1>
<p id="rfc.section.17.p.1">This specification inherits most of its semantics from <a href="#rfc5245bis">[rfc5245bis]</a> and as a result all security considerations described there remain the same.  </p>
<h1 id="rfc.section.18"><a href="#rfc.section.18">18.</a> Acknowledgements</h1>
<p id="rfc.section.18.p.1">The authors would like to thank Bernard Aboba, Flemming Andreasen, Rajmohan Banavi, Christer Holmberg, Jonathan Lennox, Enrico Marocco, Pal Martinsen, Martin Thomson, Dale R. Worley, and Brandon Williams for their reviews and suggestions on improving this document.  </p>
<h1 id="rfc.references"><a href="#rfc.references">19.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">19.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3264">[RFC3264]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a> and <a>H. Schulzrinne</a>, "<a href="http://tools.ietf.org/html/rfc3264">An Offer/Answer Model with Session Description Protocol (SDP)</a>", RFC 3264, DOI 10.17487/RFC3264, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4566">[RFC4566]</b>
      </td>
      <td class="top"><a>Handley, M.</a>, <a>Jacobson, V.</a> and <a>C. Perkins</a>, "<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>", RFC 4566, DOI 10.17487/RFC4566, July 2006.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="rfc5245bis">[rfc5245bis]</b>
      </td>
      <td class="top"><a>Keranen, A.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/draft-ietf-ice-rfc5245bis-00">Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal</a>", Internet-Draft draft-ietf-ice-rfc5245bis-00, October 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">19.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-mmusic-trickle-ice-sip">[I-D.ietf-mmusic-trickle-ice-sip]</b>
      </td>
      <td class="top"><a>Ivov, E.</a>, <a>Thomas, T.</a>, <a>Marocco, E.</a> and <a>C. Holmberg</a>, "<a href="http://tools.ietf.org/html/draft-ietf-mmusic-trickle-ice-sip-03">A Session Initiation Protocol (SIP) usage for Trickle ICE</a>", Internet-Draft draft-ietf-mmusic-trickle-ice-sip-03, October 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.keranen-mmusic-ice-address-selection">[I-D.keranen-mmusic-ice-address-selection]</b>
      </td>
      <td class="top"><a>Ker&#258;&#164;nen, A.</a> and <a>J. Arkko</a>, "<a href="http://tools.ietf.org/html/draft-keranen-mmusic-ice-address-selection-01">Update on Candidate Address Selection for Interactive Connectivity Establishment (ICE)</a>", Internet-Draft draft-keranen-mmusic-ice-address-selection-01, July 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC1918">[RFC1918]</b>
      </td>
      <td class="top"><a>Rekhter, Y.</a>, <a>Moskowitz, B.</a>, <a>Karrenberg, D.</a>, <a>de Groot, G.</a> and <a>E. Lear</a>, "<a href="http://tools.ietf.org/html/rfc1918">Address Allocation for Private Internets</a>", BCP 5, RFC 1918, DOI 10.17487/RFC1918, February 1996.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC3261">[RFC3261]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Schulzrinne, H.</a>, <a>Camarillo, G.</a>, <a>Johnston, A.</a>, <a>Peterson, J.</a>, <a>Sparks, R.</a>, <a>Handley, M.</a> and <a>E. Schooler</a>, "<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>", RFC 3261, DOI 10.17487/RFC3261, June 2002.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4787">[RFC4787]</b>
      </td>
      <td class="top"><a>Audet, F.</a> and <a>C. Jennings</a>, "<a href="http://tools.ietf.org/html/rfc4787">Network Address Translation (NAT) Behavioral Requirements for Unicast UDP</a>", BCP 127, RFC 4787, DOI 10.17487/RFC4787, January 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5389">[RFC5389]</b>
      </td>
      <td class="top"><a>Rosenberg, J.</a>, <a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>D. Wing</a>, "<a href="http://tools.ietf.org/html/rfc5389">Session Traversal Utilities for NAT (STUN)</a>", RFC 5389, DOI 10.17487/RFC5389, October 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5766">[RFC5766]</b>
      </td>
      <td class="top"><a>Mahy, R.</a>, <a>Matthews, P.</a> and <a>J. Rosenberg</a>, "<a href="http://tools.ietf.org/html/rfc5766">Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)</a>", RFC 5766, DOI 10.17487/RFC5766, April 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="XEP-0030">[XEP-0030]</b>
      </td>
      <td class="top"><a title="Cisco">Hildebrand, J.</a>, <a>Millard, P.</a>, <a>Eatmon, R.</a> and <a>P. Saint-Andre</a>, "<a>XEP-0030: Service Discovery</a>", XEP XEP-0030, June 2008.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="XEP-0176">[XEP-0176]</b>
      </td>
      <td class="top"><a title="Google">Beda, J.</a>, <a title="Google">Ludwig, S.</a>, <a>Saint-Andre, P.</a>, <a title="Cisco">Hildebrand, J.</a>, <a title="Google">Egan, S.</a> and <a title="Collabora">R. McQueen</a>, "<a>XEP-0176: Jingle ICE-UDP Transport Method</a>", XEP XEP-0176, June 2009.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="XEP-0278">[XEP-0278]</b>
      </td>
      <td class="top"><a>Camargo, T.</a>, "<a>XEP-0278: Jingle Relay Nodes</a>", XEP XEP-0278, June 2011.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.appendix.A"><a href="#rfc.appendix.A">Appendix A.</a> <a href="#interaction" id="interaction">Interaction with ICE</a></h1>
<p id="rfc.section.A.p.1">The ICE protocol was designed to be flexible enough to work in and adapt to as many network environments as possible. Despite that flexibility, ICE as specified in <a href="#rfc5245bis">[rfc5245bis]</a> does not by itself support trickle ICE. This section describes how trickling of candidates interacts with ICE.  </p>
<p><a href="#rfc5245bis">[rfc5245bis]</a> describes the conditions required to update check lists and timer states while an ICE agent is in the Running state. These conditions are verified upon transaction completion and one of them stipulates that: </p>
<p/>

<ul class="empty">
  <li>If there is not a pair in the valid list for each component of the media stream, the state of the check list is set to Failed.  </li>
</ul>

<p> </p>
<p id="rfc.section.A.p.4">This could be a problem and cause ICE processing to fail prematurely in a number of scenarios. Consider the following case: </p>
<p/>

<ol>
  <li>Alice and Bob are both located in different networks with Network Address Translation (NAT). Alice and Bob themselves have different address but both networks use the same <a href="#RFC1918">[RFC1918]</a> block.  </li>
  <li>Alice sends Bob the candidate 10.0.0.10 which also happens to correspond to an existing host on Bob's network.  </li>
  <li>Bob creates a check list consisting solely of 10.0.0.10 and starts checks.  </li>
  <li>These checks reach the host at 10.0.0.10 in Bob's network, which responds with an ICMP "port unreachable" error and per <a href="#rfc5245bis">[rfc5245bis]</a> Bob marks the transaction as Failed.  </li>
</ol>

<p> At this point the check list only contains Failed candidates and the valid list is empty. This causes the media stream and potentially all ICE processing to Fail.  </p>
<p id="rfc.section.A.p.6">A similar race condition would occur if the initial offer from Alice only contains candidates that can be determined as unreachable (per <a href="#I-D.keranen-mmusic-ice-address-selection">[I-D.keranen-mmusic-ice-address-selection]</a>) from any of the candidates that Bob has gathered. This would be the case if Bob's candidates only contain IPv4 addresses and the first candidate that he receives from Alice is an IPv6 one.  </p>
<p id="rfc.section.A.p.7">Another potential problem could arise when a non-trickle ICE implementation sends an offer to a trickle one. Consider the following case: </p>

<ol>
  <li>Alice's client has a non-Trickle ICE implementation </li>
  <li>Bob's client has support for Trickle ICE.  </li>
  <li>Alice and Bob are behind NATs with address-dependent filtering <a href="#RFC4787">[RFC4787]</a>.  </li>
  <li>Bob has two STUN servers but one of them is currently unreachable </li>
</ol>

<p> </p>
<p id="rfc.section.A.p.8">After Bob's agent receives Alice's offer it would immediately start connectivity checks. It would also start gathering candidates, which would take a long time because of the unreachable STUN server. By the time Bob's answer is ready and sent to Alice, Bob's connectivity checks may well have failed: until Alice gets Bob's answer, she won't be able to start connectivity checks and punch holes in her NAT. The NAT would hence be filtering Bob's checks as originating from an unknown endpoint.  </p>
<h1 id="rfc.appendix.B"><a href="#rfc.appendix.B">Appendix B.</a> Interaction with ICE Lite</h1>
<p id="rfc.section.B.p.1">The behavior of ICE lite agents that are capable of Trickle ICE does not require any particular rules other than those already defined in this specification and <a href="#rfc5245bis">[rfc5245bis]</a>. This section is hence provided only for informational purposes.  </p>
<p id="rfc.section.B.p.2">Such an agent would generate offers or answers as per <a href="#rfc5245bis">[rfc5245bis]</a>. Both its offers and answers will indicate support for Trickle ICE. Given that they will contain a complete set of candidates (the agent's host candidates), these offers and answers would also be accompanied with an end-of-candidates indication.  </p>
<p id="rfc.section.B.p.3">When performing full trickle, a full ICE implementation could send an offer or an answer with no candidates. After receiving an answer that identifies the remote agent as an ICE lite implementation, the offerer may choose to not send any additional candidates. The same is also true in the case when the ICE lite agent is making the offer and the full ICE one is answering. In these cases the connectivity checks would be enough for the ICE lite implementation to discover all potentially useful candidates as peer reflexive. The following example illustrates one such ICE session using SDP syntax: </p>
<div id="rfc.figure.2"/>
<div id="fig-ice-lite"/>
<pre>

        ICE Lite                                          Bob
         Agent
           |   Offer (a=ice-lite a=ice-options:trickle)    |
           |----------------------------------------------&gt;|
           |                                               |no cand
           |         Answer (a=ice-options:trickle)        |trickling
           |&lt;----------------------------------------------|
           |              Connectivity Checks              |
           |&lt;---------------------------------------------&gt;|
  peer rflx|                                               |
 cand disco|                                               |
           |                                               |
           |&lt;=============== MEDIA FLOWS =================&gt;|


        </pre>
<p class="figure">Figure 2: Example </p>
<p id="rfc.section.B.p.4">In addition to reducing signaling traffic this approach also removes the need to discover STUN bindings, or to make TURN or UPnP allocations, which may considerably lighten ICE processing.  </p>
<h1 id="rfc.appendix.C"><a href="#rfc.appendix.C">Appendix C.</a> Changes from Earlier Versions</h1>
<p id="rfc.section.C.p.1">Note to the RFC-Editor: please remove this section prior to publication as an RFC.  </p>
<h1 id="rfc.appendix.C.1"><a href="#rfc.appendix.C.1">C.1.</a> Changes from draft-ietf-ice-trickle-00</h1>
<p/>

<ul>
  <li>Removed dependency on SDP (which is to be provided in a separate specification).  </li>
  <li>Clarified text about the fact that a check list can be empty if no candidates have been sent or received yet.  </li>
  <li>Clarified wording about check list states so as not to define new states for "Active" and "Frozen" because those states are not defined for check lists (only for candidate pairs) in ICE core.  </li>
  <li>Removed open issues list because it was out of date.  </li>
  <li>Completed a thorough copy edit.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.C.2"><a href="#rfc.appendix.C.2">C.2.</a> Changes from draft-mmusic-trickle-ice-02</h1>
<p/>

<ul>
  <li>Addressed feedback from Rajmohan Banavi and Brandon Williams.  </li>
  <li>Clarified text about determining support and about how to proceed if it can be determined that the answering agent does not support Trickle ICE.  </li>
  <li>Clarified text about check list and timer updates.  </li>
  <li>Clarified when it is appropriate to use half trickle or to send no candidates in an offer or answer.  </li>
  <li>Updated the list of open issues.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.C.3"><a href="#rfc.appendix.C.3">C.3.</a> Changes from draft-ivov-01 and draft-mmusic-00</h1>
<p/>

<ul>
  <li>Added a requirement to trickle candidates by order of components to avoid deadlocks in the unfreezing algorithm.  </li>
  <li>Added an informative note on peer-reflexive candidates explaining that nothing changes for them semantically but they do become a more likely occurrence for Trickle ICE.  </li>
  <li>Limit the number of pairs to 100 to comply with 5245.  </li>
  <li>Added clarifications on the non-importance of how newly discovered candidates are trickled/sent to the remote party or if this is done at all.  </li>
  <li>Added transport expectations for trickled candidates as per Dale Worley's recommendation.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.C.4"><a href="#rfc.appendix.C.4">C.4.</a> Changes from draft-ivov-00</h1>
<p/>

<ul>
  <li>Specified that end-of-candidates is a media level attribute which can of course appear as session level, which is equivalent to having it appear in all m-lines.  Also made end-of-candidates optional for cases such as aggressive nomination for controlled agents.  </li>
  <li>Added an example for ICE lite and Trickle ICE to illustrate how, when talking to an ICE lite agent doesn't need to send or even discover any candidates.  </li>
  <li>Added an example for ICE lite and Trickle ICE to illustrate how, when talking to an ICE lite agent doesn't need to send or even discover any candidates.  </li>
  <li>Added wording that explicitly states ICE lite agents have to be prepared to receive no candidates over signalling and that they should not freak out if this happens. (Closed the corresponding open issue).  </li>
  <li>It is now mandatory to use MID when trickling candidates and using m-line indexes is no longer allowed.  </li>
  <li>Replaced use of 0.0.0.0 to IP6 :: in order to avoid potential issues with RFC2543 SDP libraries that interpret 0.0.0.0 as an on-hold operation. Also changed the port number here from 1 to 9 since it already has a more appropriate meaning. (Port change suggested by Jonathan Lennox).  </li>
  <li>Closed the Open Issue about use about what to do with cands received after end-of-cands. Solution: ignore, do an ICE restart if you want to add something.  </li>
  <li>Added more terminology, including trickling, trickled candidates, half trickle, full trickle, </li>
  <li>Added a reference to the SIP usage for Trickle ICE as requested at the Boston interim.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.C.5"><a href="#rfc.appendix.C.5">C.5.</a> Changes from draft-rescorla-01</h1>
<p/>

<ul>
  <li>Brought back explicit use of Offer/Answer. There are no more attempts to try to do this in an O/A independent way.  Also removed the use of ICE Descriptions.  </li>
  <li>Added SDP specification for trickled candidates, the trickle option and 0.0.0.0 addresses in m-lines, and end-of-candidates.  </li>
  <li>Support and Discovery. Changed that section to be less abstract. As discussed in IETF85, the draft now says implementations and usages need to either determine support in advance and directly use trickle, or do half trickle. Removed suggestion about use of discovery in SIP or about letting implementing protocols do what they want.  </li>
  <li>Defined Half Trickle. Added a section that says how it works. Mentioned that it only needs to happen in the first o/a (not necessary in updates), and added Jonathan's comment about how it could, in some cases, offer more than half the improvement if you can pre-gather part or all of your candidates before the user actually presses the call button.  </li>
  <li>Added a short section about subsequent offer/answer exchanges.  </li>
  <li>Added a short section about interactions with ICE Lite implementations.  </li>
  <li>Added two new entries to the open issues section.  </li>
</ul>

<p> </p>
<h1 id="rfc.appendix.C.6"><a href="#rfc.appendix.C.6">C.6.</a> Changes from draft-rescorla-00</h1>
<p/>

<ul>
  <li>Relaxed requirements about verifying support following a discussion on MMUSIC.  </li>
  <li>Introduced ICE descriptions in order to remove ambiguous use of 3264 language and inappropriate references to offers and answers.  </li>
  <li>Removed inappropriate assumption of adoption by RTCWEB pointed out by Martin Thomson.  </li>
</ul>

<p> </p>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Emil Ivov</span> 
	  <span class="n hidden">
		<span class="family-name">Ivov</span>
	  </span>
	</span>
	<span class="org vcardline">Jitsi</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality">Strasbourg</span>,  
		<span class="region"></span>
		<span class="code">67000</span>
	  </span>
	  <span class="country-name vcardline">France</span>
	</span>
	<span class="vcardline">Phone: +33 6 72 81 15 55</span>

<span class="vcardline">EMail: <a href="mailto:emcho@jitsi.org">emcho@jitsi.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Eric Rescorla</span> 
	  <span class="n hidden">
		<span class="family-name">Rescorla</span>
	  </span>
	</span>
	<span class="org vcardline">RTFM, Inc.</span>
	<span class="adr">
	  <span class="vcardline">2064 Edgewood Drive</span>

	  <span class="vcardline">
		<span class="locality">Palo Alto</span>,  
		<span class="region">CA</span> 
		<span class="code">94303</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 650 678 2350</span>

<span class="vcardline">EMail: <a href="mailto:ekr@rtfm.com">ekr@rtfm.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Justin Uberti</span> 
	  <span class="n hidden">
		<span class="family-name">Uberti</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span class="vcardline">747 6th St S</span>

	  <span class="vcardline">
		<span class="locality">Kirkland</span>,  
		<span class="region">WA</span> 
		<span class="code">98033</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">Phone: +1 857 288 8888</span>

<span class="vcardline">EMail: <a href="mailto:justin@uberti.name">justin@uberti.name</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Peter Saint-Andre</span> 
	  <span class="n hidden">
		<span class="family-name">Saint-Andre</span>
	  </span>
	</span>
	<span class="org vcardline">&yet</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:peter@andyet.com">peter@andyet.com</a></span>

<span class="vcardline">URI: <a href="https://andyet.com/">https://andyet.com/</a></span>

  </address>
</div>

</body>
</html>
